import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "npm:@supabase/supabase-js@2.87.1";
import { GoogleGenerativeAI } from "npm:@google/generative-ai@0.21.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey",
};

interface TransformationRequest {
  imageBase64: string;
  currentWeight: number;
  goalWeight: number;
  height: number;
  leadId?: string;
}

const supabase = createClient(
  Deno.env.get("SUPABASE_URL") ?? "",
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
);

async function generateHash(data: string): Promise<string> {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  const hashBuffer = await crypto.subtle.digest("SHA-256", dataBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

function createTransformationPrompt(
  currentWeight: number,
  goalWeight: number,
  height: number
): string {
  const weightDiff = currentWeight - goalWeight;
  const bmiCurrent = currentWeight / Math.pow(height / 100, 2);
  const bmiGoal = goalWeight / Math.pow(height / 100, 2);
  const weightLossPercentage = (weightDiff / currentWeight) * 100;

  return `CRITICAL INSTRUCTIONS - FACIAL PRESERVATION:
You MUST keep the person's face EXACTLY as it appears in the original image. DO NOT change:
- Facial features, structure, or appearance
- Skin tone or complexion
- Hair style, color, or length
- Eyes, nose, mouth, or any facial characteristics
- Age or ethnicity
- Expression or head position

PRESERVE COMPLETELY:
- The same clothing they're wearing
- The background and environment
- The lighting and photo quality
- The camera angle and pose

TRANSFORM ONLY THE BODY:
Transform this person's body to show realistic weight loss of ${weightDiff.toFixed(1)}kg (${weightLossPercentage.toFixed(1)}% body weight reduction).
Starting BMI: ${bmiCurrent.toFixed(1)} â†’ Goal BMI: ${bmiGoal.toFixed(1)}

Body transformation changes:
- Reduce overall body fat naturally and proportionally
- Show more defined muscle tone and definition
- Create a slimmer, more toned silhouette
- Improve posture with confident body language
- Reduce waist circumference and belly fat
- Show natural fat reduction in arms, legs, and torso
- Maintain realistic and achievable proportions

The result should be:
- Photorealistic and natural-looking
- Professionally photographed quality
- Motivating and inspiring
- Achievable through healthy diet and exercise
- Same person, just with a healthier, leaner body

Remember: The face, hair, clothing, and background MUST remain identical. Only the body shape changes.`;
}

async function transformImageWithGemini(
  imageBase64: string,
  prompt: string,
  maxRetries: number = 3
): Promise<string> {
  const apiKey = Deno.env.get("GOOGLE_AI_API_KEY");

  if (!apiKey) {
    throw new Error("GOOGLE_AI_API_KEY not configured. Get your key at https://ai.google.dev/");
  }

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

  const imageData = imageBase64.replace(/^data:image\/[a-z]+;base64,/, "");

  const mimeType = imageBase64.match(/data:image\/([a-z]+);base64,/)?.[1] || "jpeg";
  const fullMimeType = `image/${mimeType}`;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt}/${maxRetries} - Calling Gemini 2.0 Flash Exp API...`);

      const result = await model.generateContent([
        {
          inlineData: {
            data: imageData,
            mimeType: fullMimeType,
          },
        },
        { text: prompt },
      ]);

      const response = await result.response;

      if (!response.candidates || response.candidates.length === 0) {
        throw new Error("No image generated by Gemini");
      }

      const candidate = response.candidates[0];

      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        throw new Error("No content parts in Gemini response");
      }

      const imagePart = candidate.content.parts.find((part: any) => part.inlineData);

      if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {
        throw new Error("No image data in Gemini response");
      }

      console.log("Successfully generated transformation with Gemini");
      return imagePart.inlineData.data;

    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error);

      if (attempt === maxRetries) {
        throw new Error(`Failed after ${maxRetries} attempts: ${error instanceof Error ? error.message : "Unknown error"}`);
      }

      const backoffDelay = Math.pow(2, attempt) * 1000;
      console.log(`Retrying in ${backoffDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, backoffDelay));
    }
  }

  throw new Error("Failed to generate image after all retries");
}

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    });
  }

  const startTime = Date.now();
  let leadId: string | null = null;

  try {
    const {
      imageBase64,
      currentWeight,
      goalWeight,
      height,
      leadId: requestLeadId,
    }: TransformationRequest = await req.json();

    leadId = requestLeadId || null;

    if (!imageBase64 || !currentWeight || !goalWeight || !height) {
      return new Response(
        JSON.stringify({ error: "Missing required parameters" }),
        {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    const imageHash = await generateHash(imageBase64);

    const { data: cachedTransformation } = await supabase
      .from("image_transformations")
      .select("transformed_url")
      .eq("original_hash", imageHash)
      .gt("expires_at", new Date().toISOString())
      .maybeSingle();

    if (cachedTransformation?.transformed_url) {
      console.log("Cache hit - returning cached transformation");

      if (leadId) {
        await supabase.from("transformation_logs").insert({
          lead_id: leadId,
          status: "success",
          processing_time_ms: Date.now() - startTime,
        });
      }

      return new Response(
        JSON.stringify({
          transformedImage: cachedTransformation.transformed_url,
          cached: true,
        }),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    console.log("Cache miss - generating new transformation");
    const prompt = createTransformationPrompt(currentWeight, goalWeight, height);

    console.log("Transforming image with Gemini 2.0 Flash Exp...");
    const transformedImageBase64 = await transformImageWithGemini(imageBase64, prompt);

    const imageBytes = Uint8Array.from(atob(transformedImageBase64), c => c.charCodeAt(0));
    const imageBlob = new Blob([imageBytes], { type: "image/png" });
    const fileName = `${crypto.randomUUID()}.png`;

    console.log("Uploading to Supabase Storage...");
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("transformed-images")
      .upload(fileName, imageBlob, {
        contentType: "image/png",
        cacheControl: "3600",
        upsert: false,
      });

    if (uploadError) {
      console.error("Storage upload error:", uploadError);
      throw new Error(`Failed to upload image: ${uploadError.message}`);
    }

    const { data: publicUrlData } = supabase.storage
      .from("transformed-images")
      .getPublicUrl(fileName);

    const transformedUrl = publicUrlData.publicUrl;

    const { error: cacheError } = await supabase
      .from("image_transformations")
      .insert({
        lead_id: leadId,
        original_hash: imageHash,
        transformed_url: transformedUrl,
      });

    if (cacheError) {
      console.error("Cache insert error:", cacheError);
    }

    if (leadId) {
      await supabase.from("transformation_logs").insert({
        lead_id: leadId,
        status: "success",
        processing_time_ms: Date.now() - startTime,
      });
    }

    return new Response(
      JSON.stringify({
        transformedImage: transformedUrl,
        cached: false,
      }),
      {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  } catch (error) {
    console.error("Error:", error);

    if (leadId) {
      await supabase.from("transformation_logs").insert({
        lead_id: leadId,
        status: "error",
        error_message: error instanceof Error ? error.message : "Unknown error",
        processing_time_ms: Date.now() - startTime,
      });
    }

    return new Response(
      JSON.stringify({
        error: error instanceof Error ? error.message : "Unknown error",
        fallback: true,
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
